package network;

import games.reversi.ReversiModel;
import games.reversi.Vector2;
import java.util.HashMap;
import java.util.Map;

/**
 * Handler class to handle all responses recieved from the server through the
 * Receiver class
 *
 * @author Zein Bseis
 * @version 3.0
 */
public class HandlerModel {
    /**
     * An array of player names.
     */
    public String[] playerlist;

//    private String opponent;
//    private String gameName;

    /**
     * Boolean variable for when the client is inside a match.
     */
    private boolean inMatch = false;

//    Sender sender = new Sender(Connection.getConnection().getSocket());

    /**
     * Reference to the Game model to exchange processed data.
     */
    private ReversiModel game;

    /**
     * couple the handler with a game model.
     *
     * @param game
     */
    public HandlerModel(ReversiModel game) {
        this.game = game;
    }

    /**
     * If an Error was generated by the server this error will be caught by this handler
     *
     * @param response raw response from the server
     * @return raw response from the server
     */
    public String errHandler (String response) {
        return response;
    }

    /**
     * Handler for the help command
     *
     * @return a string indicating where to get help
     */
    public String helpHandler () {
        return "For help information checkout Protocol.txt on Blackboard";
    }

    /**
     * if a new game has started
     *
     * @return String that indicated that a new game has started
     */
    public String gameMatchHandler() {
        inMatch = true;
        
        game.gameStart(ReversiModel.GameMode.ONLINE);
        
        return "newGame";
    }

    /**
     * The move comes from the server in a specific form, here is where the
     * form is made understandable for the Reversi game
     *
     * @param response from the server containing the move details
     */
    public void gameMoveHandler(String response) {
        HashMap<String, String> map = responseToMap(response);
        String player = map.get("PLAYER");
        String move = map.get("MOVE");
        
        game.log("Opponent("+player+") moved("+move+")");
        
        if (!player.equals(game.getClientName())) {
            Vector2 pos = game.getBoard().convertIndexToPosition(Integer.parseInt(move));
            game.clickPosition((int)pos.x, (int)pos.y);
        }
    }

    /**
     * When it is the client's turn to make a move
     */
    public void turnHandler() {
        if (game.getGameMode() != ReversiModel.GameMode.ONLINE) return;
        
//        game.log("your turn...");
        
        game.getBoard().setPlayerTurn(true);
        game.turnStart();
        game.AiMove();
    }

    /**
     * The server message indicating the client has won the match.
     */
    public void winHandler() {
        inMatch = false;
        game.gameEnd(true);
    }

    /**
     * for when the client has lost a game
     */
    public void lossHandler() {
        inMatch = false;
        game.gameEnd(false);
    }

    /**
     * coverts a server response in the form of a string to an array that could be used
     * to chose a player to challenge for example
     *
     * @param response An array containing the players list
     */
    public void playerlistHandler(String response) {
        response = stringCleaner(response);
        String[] responseArray = toArray(response);
        playerlist = responseArray;
    }
    
    /**
     * When receiving a challenge, this handler is called.
     *
     * @param response the response message.
     */
    public void gameChallengeHandler(String response) {
        if (inMatch) return;
        
        Map<String, String> result = responseToMap(response);
        
        String challenger = result.get("CHALLENGER");
        String challengeNr = result.get("CHALLENGENUMBER");
        
//        game.acceptChallenge(challengeNr);
        game.challengeReceived(challenger, challengeNr);
    }

    public void gameDrawHandler(String response) { //  implement draw condition
         }

    /**
     * clean the server response in order for it to be easly split into an array
     *
     * @param dirty A string response from the server
     * @return A string without all the server extras
     */
    private String stringCleaner(String dirty) {
        dirty = dirty.substring(dirty.indexOf("[") + 1,dirty.indexOf("]"));
        dirty = dirty.replace("\"","");
//        dirty = dirty.replace(",","");
        return dirty;
    }

    /**
     *Converting a string to array by splitting on commas
     *
     * @param string with  plain player names separated with commas
     * @return an array containing the names of player
     */
    public String[] toArray (String string) {
        String[] anArray = string.split(",");
        return anArray;
    }

    /**
     *Converting the server response onto a Hashmap.
     *
     * @param response A string containing the raw server response
     * @return a Hashmap with the response details sorted out
     */
    private HashMap<String, String> responseToMap(String response) {
        String server_msg = response.substring(response.indexOf('{') + 1, response.indexOf('}'));
        HashMap<String, String> map = new HashMap<String, String>();
        String[] list = server_msg.split(",");
        for (int i = 0; i < list.length; i++) {
            list[i] = list[i].trim();
            String[] keyvalue = list[i].split(":");
            map.put(keyvalue[0].trim(), keyvalue[1].replace("\"", "").trim());
        }
        return map;
    }


}
